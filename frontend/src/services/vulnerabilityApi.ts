import apiClient from './apiClient';
import { ScanJob, ScanConfig, ScanResult, Vulnerability, CredentialConfig, DashboardStats } from '../types/vulnerability';

export interface VulnerabilityScanRequest {
  target: string;
  assessment_type: 'full' | 'web_security' | 'ssl_analysis' | 'cve_scan' | 'credential_testing';
  aggressive?: boolean;
  web_scan_config?: {
    directory_enum?: boolean;
    header_analysis?: boolean;
    ssl_analysis?: boolean;
  };
  ssl_config?: {
    check_protocols?: boolean;
    check_ciphers?: boolean;
    check_certificate?: boolean;
  };
  cve_config?: {
    check_known_vulnerabilities?: boolean;
    version_detection?: boolean;
  };
  credential_config?: CredentialConfig;
}

export interface VulnerabilityStats {
  severity_distribution: Record<string, number>;
  status_distribution: Record<string, number>;
  recent_critical: Vulnerability[];
  total_vulnerabilities: number;
}

class VulnerabilityApi {
  async startScan(config: VulnerabilityScanRequest): Promise<{ job_id: string; status: string; message: string }> {
    const response = await apiClient.post('/api/vulnerability/scan', config);
    return response.data;
  }

  // In vulnerabilityApi.ts - update getScanStatus method
  async getScanStatus(jobId: string): Promise<ScanJob> {
    try {
      const response = await apiClient.get(`/api/vulnerability/scan/${jobId}`);
      
      // Ensure the response has the expected structure
      const scanJob: ScanJob = {
        id: response.id,
        target: response.target,
        scan_type: response.scan_type,
        profile: response.profile,
        status: response.status,
        progress: response.progress || 0,
        created_at: response.created_at,
        updated_at: response.updated_at,
        finished_at: response.finished_at,
        duration: response.duration,
        log: response.log,
        error: response.error,
        error_message: response.error_message,
        asset_id: response.asset_id,
        insights: response.insights,
        vulnerability_results: response.vulnerability_results,
        config: response.config,
        parent_scan_id: response.parent_scan_id,
        type: response.type
      };
      
      return scanJob;
    } catch (error) {
      console.error('Failed to fetch scan status:', error);
      throw error;
    }
  }

  // In vulnerabilityApi.ts
  async getScans(page: number = 1, perPage: number = 10): Promise<{
    scans: ScanJob[];
    total: number;
    pages: number;
    current_page: number;
  }> {
    try {
      const response = await apiClient.get(`/api/vulnerability/scans?page=${page}&per_page=${perPage}`);
      
      // Handle different response structures
      if (response && typeof response === 'object') {
        return {
          scans: response.scans || response.data?.scans || [],
          total: response.total || response.data?.total || 0,
          pages: response.pages || response.data?.pages || 0,
          current_page: response.current_page || response.data?.current_page || page
        };
      }
      
      return { scans: [], total: 0, pages: 0, current_page: page };
    } catch (error) {
      console.error('Failed to fetch scans:', error);
      return { scans: [], total: 0, pages: 0, current_page: page };
    }
  }

  async getVulnerabilities(
    page: number = 1,
    perPage: number = 20,
    severity?: string,
    status?: string
  ): Promise<{
    vulnerabilities: Vulnerability[];
    total: number;
    pages: number;
    current_page: number;
  }> {
    try {
      const params: any = { page, per_page: perPage };
      if (severity) params.severity = severity;
      if (status) params.status = status;
      
      const response = await apiClient.get('/api/vulnerability/findings', { params });
      
      // Handle different response structures
      if (response && typeof response === 'object') {
        return {
          vulnerabilities: response.vulnerabilities || 
                          response.data?.vulnerabilities || 
                          response.results?.vulnerabilities || 
                          [],
          total: response.total || response.data?.total || 0,
          pages: response.pages || response.data?.pages || 0,
          current_page: response.current_page || response.data?.current_page || page
        };
      }
      
      return { vulnerabilities: [], total: 0, pages: 0, current_page: page };
    } catch (error) {
      console.error('Failed to fetch vulnerabilities:', error);
      return { vulnerabilities: [], total: 0, pages: 0, current_page: page };
    }
  }

  async getVulnerabilityStats(): Promise<any> {
    try {
      const response = await apiClient.get('/api/vulnerability/stats');
      return response || {};
    } catch (error) {
      console.error('Failed to fetch vulnerability stats:', error);
      return {
        severity_distribution: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 },
        status_distribution: { open: 0, fixed: 0, risk_accepted: 0, false_positive: 0 },
        recent_critical: [],
        total_vulnerabilities: 0
      };
    }
  }
}

export default new VulnerabilityApi();