import requests
import re
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin, urlparse
import time

class WebVulnerabilityScanner:
    def __init__(self):
        self.common_paths = [
            '/admin', '/administrator', '/login', '/wp-admin', '/phpmyadmin',
            '/backup', '/backups', '/.git', '/.env', '/config',
            '/api', '/graphql', '/swagger', '/phpinfo.php',
            '/test', '/debug', '/console', '/.well-known'
        ]
        
        self.sql_injection_patterns = [
            "' OR '1'='1",
            "' OR 1=1--",
            "'; DROP TABLE users--",
            "' UNION SELECT 1,2,3--"
        ]
        
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>"
        ]
    
    def comprehensive_web_scan(self, url: str) -> Dict[str, Any]:
        """Comprehensive web vulnerability scanning with improved error handling"""
        try:
            # Normalize the target URL
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            results = {
                'url': url,
                'scan_time': time.time(),
                'vulnerabilities': [],
                'security_headers': {},
                'information_disclosure': [],
                'directory_traversal': [],
                'injection_vulnerabilities': []
            }
            
            # Test if target is accessible with better error handling
            try:
                response = requests.get(
                    url, 
                    timeout=10, 
                    verify=False,
                    headers={
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                    },
                    allow_redirects=True
                )
                
                # Check for HTTP errors
                if response.status_code >= 400:
                    return {
                        'error': f'Target returned HTTP {response.status_code}',
                        'url': url,
                        'status_code': response.status_code
                    }
                    
                # Store response for further analysis
                target_response = response
                
            except requests.exceptions.SSLError as e:
                # Try with HTTP if HTTPS fails
                if url.startswith('https://'):
                    http_url = url.replace('https://', 'http://')
                    try:
                        response = requests.get(
                            http_url,
                            timeout=10,
                            headers={
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            },
                            allow_redirects=True
                        )
                        target_response = response
                        results['url'] = http_url  # Update to the working URL
                        results['ssl_issue'] = 'HTTPS failed, using HTTP'
                    except requests.exceptions.RequestException:
                        return {
                            'error': f'SSL error and HTTP fallback failed: {str(e)}',
                            'url': url
                        }
                else:
                    return {
                        'error': f'SSL error: {str(e)}',
                        'url': url
                    }
                    
            except requests.exceptions.Timeout:
                return {
                    'error': 'Target request timed out (10 seconds)',
                    'url': url
                }
                
            except requests.exceptions.ConnectionError as e:
                return {
                    'error': f'Connection error: {str(e)}',
                    'url': url
                }
                
            except requests.exceptions.RequestException as e:
                return {
                    'error': f'Request failed: {str(e)}',
                    'url': url
                }
            
            # If we have a successful response, run security checks
            try:
                # Run various security checks
                results['vulnerabilities'].extend(self._check_security_headers(target_response))
                results['vulnerabilities'].extend(self._check_information_disclosure(target_response))
                results['directory_traversal'].extend(self._check_directory_traversal(url))
                results['injection_vulnerabilities'].extend(self._check_injection_vectors(url))
                
                # Add response metadata
                results['status_code'] = target_response.status_code
                results['headers'] = dict(target_response.headers)
                results['content_length'] = len(target_response.content)
                
                # Calculate overall risk
                results['risk_assessment'] = self._assess_risk(results['vulnerabilities'])
                
                return results
                
            except Exception as scan_error:
                # If scanning fails but we have a response, return partial results
                return {
                    'error': f'Scanning failed after successful connection: {str(scan_error)}',
                    'url': url,
                    'status_code': target_response.status_code if 'target_response' in locals() else None,
                    'partial_results': results
                }
                
        except Exception as e:
            return {
                'error': f"Web vulnerability scan failed: {str(e)}",
                'url': url
            }


    def _make_request(self, url: str, timeout: int = 10) -> Optional[requests.Response]:
        """Helper method to make HTTP requests with comprehensive error handling"""
        try:
            response = requests.get(
                url,
                timeout=timeout,
                verify=False,
                headers={
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                },
                allow_redirects=True
            )
            return response
            
        except requests.exceptions.SSLError:
            # Try HTTP if HTTPS fails
            if url.startswith('https://'):
                http_url = url.replace('https://', 'http://')
                try:
                    return requests.get(
                        http_url,
                        timeout=timeout,
                        headers={
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        },
                        allow_redirects=True
                    )
                except requests.exceptions.RequestException:
                    return None
            return None
            
        except requests.exceptions.RequestException:
            return None
    
    def _check_security_headers(self, response: requests.Response) -> List[Dict[str, Any]]:
        """Check for missing security headers"""
        vulnerabilities = []
        headers = response.headers
        
        security_headers = {
            'Content-Security-Policy': {
                'severity': 'MEDIUM',
                'description': 'Missing Content Security Policy header',
                'recommendation': 'Implement CSP to prevent XSS attacks'
            },
            'X-Frame-Options': {
                'severity': 'MEDIUM', 
                'description': 'Missing X-Frame-Options header',
                'recommendation': 'Implement X-Frame-Options to prevent clickjacking'
            },
            'X-Content-Type-Options': {
                'severity': 'LOW',
                'description': 'Missing X-Content-Type-Options header',
                'recommendation': 'Set X-Content-Type-Options: nosniff'
            },
            'Strict-Transport-Security': {
                'severity': 'HIGH',
                'description': 'Missing HSTS header',
                'recommendation': 'Implement HSTS to enforce HTTPS'
            },
            'Referrer-Policy': {
                'severity': 'LOW',
                'description': 'Missing Referrer-Policy header',
                'recommendation': 'Implement Referrer-Policy to control referrer information'
            }
        }
        
        for header, info in security_headers.items():
            if header not in headers:
                vulnerabilities.append({
                    'type': f'MISSING_{header.upper().replace("-", "_")}',
                    'severity': info['severity'],
                    'description': info['description'],
                    'recommendation': info['recommendation'],
                    'evidence': f'Header {header} not present'
                })
        
        return vulnerabilities
    
    def _check_information_disclosure(self, response: requests.Response) -> List[Dict[str, Any]]:
        """Check for information disclosure vulnerabilities"""
        vulnerabilities = []
        content = response.text
        headers = response.headers
        
        # Check for server version disclosure
        server = headers.get('Server', '')
        if server and server not in ['', 'None']:
            vulnerabilities.append({
                'type': 'SERVER_VERSION_DISCLOSURE',
                'severity': 'LOW',
                'description': f'Server version disclosed: {server}',
                'recommendation': 'Remove or obscure server version information',
                'evidence': f'Server header: {server}'
            })
        
        # Check for framework disclosure
        powered_by = headers.get('X-Powered-By', '')
        if powered_by:
            vulnerabilities.append({
                'type': 'FRAMEWORK_DISCLOSURE',
                'severity': 'LOW',
                'description': f'Technology stack disclosed: {powered_by}',
                'recommendation': 'Remove X-Powered-By header',
                'evidence': f'X-Powered-By: {powered_by}'
            })
        
        # Check for sensitive information in content
        sensitive_patterns = {
            'EMAIL_DISCLOSURE': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            'IP_ADDRESS_DISCLOSURE': r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b',
            'API_KEY_DISCLOSURE': r'[A-Za-z0-9]{32,}',
            'DATABASE_CONNECTION_STRING': r'(\b\w+://[^:]+:[^@]+@[^\s]+\b)'
        }
        
        for vuln_type, pattern in sensitive_patterns.items():
            matches = re.findall(pattern, content)
            if matches:
                vulnerabilities.append({
                    'type': vuln_type,
                    'severity': 'HIGH',
                    'description': f'Sensitive information disclosed in response',
                    'recommendation': 'Remove sensitive information from public responses',
                    'evidence': f'Found {len(matches)} instances of {vuln_type.lower().replace("_", " ")}'
                })
        
        return vulnerabilities
    
    def _check_directory_traversal(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for directory traversal vulnerabilities"""
        vulnerabilities = []
        
        for path in self.common_paths:
            test_url = urljoin(base_url, path)
            response = self._make_request(test_url)
            
            if response and response.status_code in [200, 403]:
                vulnerabilities.append({
                    'type': 'SENSITIVE_PATH_EXPOSED',
                    'severity': 'MEDIUM',
                    'description': f'Sensitive path accessible: {path}',
                    'recommendation': 'Restrict access to sensitive directories',
                    'evidence': f'Path {path} returned status {response.status_code}'
                })
        
        return vulnerabilities
    
    def _check_injection_vectors(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for basic injection vulnerabilities"""
        vulnerabilities = []
        
        # Test for SQL injection in URL parameters
        parsed_url = urlparse(base_url)
        if parsed_url.query:
            for payload in self.sql_injection_patterns:
                test_url = base_url + payload
                response = self._make_request(test_url)
                
                if response and self._detect_sql_errors(response.text):
                    vulnerabilities.append({
                        'type': 'SQL_INJECTION_INDICATOR',
                        'severity': 'HIGH',
                        'description': 'Potential SQL injection vulnerability detected',
                        'recommendation': 'Implement proper input validation and parameterized queries',
                        'evidence': f'Payload triggered database error: {payload}'
                    })
                    break
        
        return vulnerabilities
    
    def _detect_sql_errors(self, content: str) -> bool:
        """Detect SQL error messages in response"""
        sql_errors = [
            'sql syntax',
            'mysql_fetch',
            'ora-',
            'microsoft odbc',
            'postgresql error',
            'warning: mysql',
            'unclosed quotation mark'
        ]
        
        content_lower = content.lower()
        return any(error in content_lower for error in sql_errors)
    
    def _assess_risk(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Assess overall risk based on vulnerabilities"""
        severity_weights = {
            'CRITICAL': 10,
            'HIGH': 7,
            'MEDIUM': 4,
            'LOW': 1
        }
        
        counts = {severity: 0 for severity in severity_weights.keys()}
        total_score = 0
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'LOW')
            if severity in counts:
                counts[severity] += 1
                total_score += severity_weights[severity]
        
        risk_score = min(100, total_score * 2)  # Scale to 100
        
        if risk_score >= 80 or counts['CRITICAL'] > 0:
            risk_level = 'CRITICAL'
        elif risk_score >= 60 or counts['HIGH'] > 2:
            risk_level = 'HIGH'
        elif risk_score >= 40 or counts['MEDIUM'] > 3:
            risk_level = 'MEDIUM'
        elif risk_score >= 20:
            risk_level = 'LOW'
        else:
            risk_level = 'INFO'
        
        return {
            'risk_score': risk_score,
            'risk_level': risk_level,
            'critical_count': counts['CRITICAL'],
            'high_count': counts['HIGH'],
            'medium_count': counts['MEDIUM'],
            'low_count': counts['LOW'],
            'total_vulnerabilities': len(vulnerabilities)
        }