import subprocess
import json
import requests
import tempfile
import os
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional
import nmap
import ssl
import socket
import OpenSSL
from datetime import datetime
import concurrent.futures
import yaml
import re
from pathlib import Path

class VulnerabilityScanner:
    def __init__(self):
        self.nm = nmap.PortScanner()
        self.temp_dir = tempfile.mkdtemp()
        
    def check_tool_availability(self) -> Dict[str, bool]:
        """Check if required security tools are available with better detection"""
        tools = {
            'nmap': self._check_command('nmap --version'),
            'nikto': self._check_command('nikto -version'),
            'testssl': self._check_command('testssl.sh --version'),
            'sqlmap': self._check_command('sqlmap --version'),
            'nuclei': self._check_command('nuclei -version'),
            'whatweb': self._check_command('whatweb --version'),
            'dirb': self._check_command('dirb --help'),
        }
        
        # Log missing tools
        missing_tools = [tool for tool, available in tools.items() if not available]
        if missing_tools:
            print(f"âš ï¸  Missing tools: {', '.join(missing_tools)}")
            print("   Scans will continue but some features may be limited")
        
        return tools
    
    def _check_command(self, command: str) -> bool:
        """Check if a command line tool is available"""
        try:
            subprocess.run(command.split(), capture_output=True, timeout=10)
            return True
        except:
            return False

    # CVE Scanning with actual tools
    def perform_cve_analysis(self, target: str, config: Dict) -> Dict:
        """Perform CVE analysis using nmap NSE scripts and vulners database"""
        services = self.discover_services(target)
        results = []
        
        for service in services:
            service_vulns = self.check_service_vulnerabilities(service, target)
            risk_assessment = self.calculate_service_risk_assessment(service_vulns)
            
            results.append({
                'service': service,
                'vulnerabilities': service_vulns,
                'risk_assessment': risk_assessment
            })
        
        summary = {
            'services_scanned': len(services),
            'vulnerable_services': len([r for r in results if r['vulnerabilities']]),
            'total_vulnerabilities': sum(len(r['vulnerabilities']) for r in results)
        }
        
        return {
            'results': results,
            'summary': summary
        }

    def discover_services(self, target: str) -> List[Dict]:
        """Discover services using nmap"""
        services = []
        
        try:
            # Run nmap service detection
            scan_result = self.nm.scan(target, arguments='-sV --version-all')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    ports = self.nm[host][proto].keys()
                    
                    for port in ports:
                        service_info = self.nm[host][proto][port]
                        service = {
                            'name': service_info.get('name', 'unknown'),
                            'version': service_info.get('version', ''),
                            'host': host,
                            'port': port,
                            'protocol': proto,
                            'product': service_info.get('product', ''),
                            'extrainfo': service_info.get('extrainfo', '')
                        }
                        services.append(service)
                        
        except Exception as e:
            print(f"Service discovery failed: {e}")
            
        return services

    def check_service_vulnerabilities(self, service: Dict, target: str) -> List[Dict]:
        """Check for service-specific vulnerabilities using nmap NSE"""
        vulnerabilities = []
        
        try:
            # Run vulnerability scripts based on service type
            service_name = service['name'].lower()
            port = service['port']
            
            if service_name in ['http', 'https', 'http-alt']:
                vulns = self.scan_web_vulnerabilities(target, port)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['ssh', 'ftp', 'telnet']:
                vulns = self.scan_auth_vulnerabilities(target, port, service_name)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['mysql', 'postgresql', 'oracle']:
                vulns = self.scan_database_vulnerabilities(target, port, service_name)
                vulnerabilities.extend(vulns)
            
            # Run general vulnerability scan with nmap NSE
            vuln_scripts = self.run_nmap_vuln_scan(target, port)
            vulnerabilities.extend(vuln_scripts)
            
        except Exception as e:
            print(f"Vulnerability check failed for {service['name']}: {e}")
            
        return vulnerabilities

    def run_nmap_vuln_scan(self, target: str, port: int) -> List[Dict]:
        """Run nmap vulnerability scripts"""
        vulnerabilities = []
        
        try:
            # Run vuln scan with common NSE scripts
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script vuln,safe')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        for script_name, script_output in scripts.items():
                            if 'vuln' in script_name.lower() or 'CVE' in script_output:
                                vulnerabilities.append({
                                    'type': f'NMAP_{script_name.upper()}',
                                    'severity': self.determine_nmap_severity(script_output),
                                    'description': f'Nmap script {script_name} detected vulnerability',
                                    'recommendation': 'Review and patch the identified service',
                                    'evidence': script_output,
                                    'source': 'nmap_nse',
                                    'cve_id': self.extract_cve_from_output(script_output)
                                })
                                
        except Exception as e:
            print(f"Nmap vuln scan failed: {e}")
            
        return vulnerabilities
    
    def is_web_service(self, target: str) -> bool:
        """Check if target appears to be a web service with better detection"""
        try:
            # Check for URL schemes
            if target.startswith(('http://', 'https://')):
                return True
            
            # Check for common web ports in target string
            if any(f':{port}' in target for port in [80, 443, 8080, 8443, 3000, 5000]):
                return True
            
            # Check if target looks like a domain name
            if '.' in target and not target.replace('.', '').isdigit():
                return True
                
            # For IP addresses, try to detect if they respond on web ports
            # This is a basic check - you might want to enhance this
            return False
            
        except Exception as e:
            print(f"Error checking if target is web service: {e}")
            # When in doubt, assume it might be a web service
            return True

    def scan_web_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Scan web vulnerabilities using multiple tools"""
        vulnerabilities = []
        
        try:
            # Normalize target URL
            if not target.startswith(('http://', 'https://')):
                # Determine protocol based on port
                protocol = 'https' if port in [443, 8443] else 'http'
                target_url = f"{protocol}://{target}:{port}"
            else:
                target_url = target
            
            print(f"ðŸ” Scanning web vulnerabilities for: {target_url}")
            
            # Run Nikto scan
            nikto_vulns = self.run_nikto_scan(target_url)
            vulnerabilities.extend(nikto_vulns)
            
            # Run Nuclei scan
            nuclei_vulns = self.run_nuclei_scan(target_url)
            vulnerabilities.extend(nuclei_vulns)
            
            # Run directory enumeration
            dir_vulns = self.perform_directory_enumeration(target_url)
            vulnerabilities.extend(dir_vulns)
            
            # Analyze HTTP headers
            header_vulns = self.analyze_http_headers(target_url)
            vulnerabilities.extend(header_vulns)
            
            # Analyze cookies
            cookie_vulns = self.analyze_cookie_security(target_url)
            vulnerabilities.extend(cookie_vulns)
            
            # Check security headers
            security_header_vulns = self.check_security_headers(target_url)
            vulnerabilities.extend(security_header_vulns)
            
        except Exception as e:
            print(f"Web vulnerability scan failed: {e}")
            vulnerabilities.append({
                'type': 'WEB_SCAN_ERROR',
                'severity': 'MEDIUM',
                'description': f'Web vulnerability scan failed: {str(e)}',
                'recommendation': 'Check target accessibility and web service availability',
                'source': 'web_scan'
            })
        
        return vulnerabilities

    def run_nikto_scan(self, target: str, port: int = 80) -> List[Dict]:
        """Run Nikto web vulnerability scanner with graceful degradation"""
        vulnerabilities = []
        
        # Check if nikto is available first
        if not self._check_command('nikto -version'):
            print("âš ï¸  Nikto not available, skipping Nikto scan")
            # Add a basic web vulnerability check as fallback
            vulnerabilities.extend(self.basic_web_vulnerability_check(target, port))
            return vulnerabilities
            
        try:
            # Your existing nikto implementation...
            protocol = 'https' if port in [443, 8443] else 'http'
            if not target.startswith(('http://', 'https://')):
                url = f"{protocol}://{target}:{port}"
            else:
                url = target
                
            print(f"ðŸ” Running Nikto scan on: {url}")
            
            cmd = f"nikto -h {url} -Format xml -o {self.temp_dir}/nikto_scan.xml"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0 and os.path.exists(f"{self.temp_dir}/nikto_scan.xml"):
                nikto_vulns = self.parse_nikto_xml(f"{self.temp_dir}/nikto_scan.xml")
                vulnerabilities.extend(nikto_vulns)
            else:
                print(f"âš ï¸  Nikto scan failed: {result.stderr}")
                # Fallback to basic checks
                vulnerabilities.extend(self.basic_web_vulnerability_check(target, port))
                
        except Exception as e:
            print(f"âŒ Nikto scan failed: {e}")
            # Fallback to basic checks
            vulnerabilities.extend(self.basic_web_vulnerability_check(target, port))
            
        return vulnerabilities

    def basic_web_vulnerability_check(self, target: str, port: int) -> List[Dict]:
        """Basic web vulnerability checks when advanced tools are unavailable"""
        vulnerabilities = []
        
        try:
            # Basic HTTP header analysis
            protocol = 'https' if port in [443, 8443] else 'http'
            if not target.startswith(('http://', 'https://')):
                url = f"{protocol}://{target}:{port}"
            else:
                url = target
                
            response = requests.get(url, timeout=10, verify=False)
            
            # Check for basic security headers
            headers = response.headers
            security_headers = ['Content-Security-Policy', 'X-Content-Type-Options', 
                            'X-Frame-Options', 'Strict-Transport-Security']
            
            for header in security_headers:
                if header not in headers:
                    vulnerabilities.append({
                        'type': f'MISSING_SECURITY_HEADER_BASIC',
                        'severity': 'MEDIUM',
                        'description': f'Missing security header: {header}',
                        'recommendation': f'Implement {header} header',
                        'evidence': f'Basic header check failed for {header}',
                        'source': 'basic_web_check'
                    })
                    
        except Exception as e:
            print(f"Basic web check failed: {e}")
            
        return vulnerabilities

    def parse_nikto_xml(self, xml_file: str) -> List[Dict]:
        """Parse Nikto XML output with better error handling"""
        vulnerabilities = []
        
        try:
            # Check if file exists and has content
            if not os.path.exists(xml_file) or os.path.getsize(xml_file) == 0:
                print(f"âš ï¸  Nikto XML file empty or missing: {xml_file}")
                return vulnerabilities
            
            # Try to parse the XML
            try:
                tree = ET.parse(xml_file)
                root = tree.getroot()
            except ET.ParseError as e:
                print(f"âš ï¸  Nikto XML parsing failed: {e}")
                # Try to extract any useful information from the file
                with open(xml_file, 'r') as f:
                    content = f.read()
                    # Look for any vulnerability patterns in the raw output
                    if "Vulnerable" in content or "vuln" in content.lower():
                        vulnerabilities.append({
                            'type': 'NIKTO_FINDING',
                            'severity': 'MEDIUM',
                            'description': 'Nikto found potential vulnerabilities (XML parsing failed)',
                            'recommendation': 'Review Nikto output manually',
                            'evidence': 'Raw Nikto output available in logs',
                            'source': 'nikto'
                        })
                return vulnerabilities
            
            # Parse successful XML
            for item in root.findall('.//item'):
                description_elem = item.find('description')
                uri_elem = item.find('uri')
                
                description = description_elem.text if description_elem is not None else 'No description'
                uri = uri_elem.text if uri_elem is not None else 'Unknown URI'
                
                vulnerability = {
                    'type': 'NIKTO_FINDING',
                    'severity': 'MEDIUM',  # Nikto findings are typically medium
                    'description': description,
                    'recommendation': 'Review and fix the identified web vulnerability',
                    'evidence': f"URI: {uri} - {description}",
                    'source': 'nikto'
                }
                vulnerabilities.append(vulnerability)
                    
        except Exception as e:
            print(f"Nikto XML parsing failed: {e}")
            # Add a generic finding so the scan doesn't completely fail
            vulnerabilities.append({
                'type': 'NIKTO_PARSE_ERROR',
                'severity': 'LOW',
                'description': f'Nikto scan completed but parsing failed: {str(e)}',
                'recommendation': 'Check Nikto installation and output format',
                'source': 'nikto'
            })
                
        return vulnerabilities

    def run_whatweb_scan(self, target: str, port: int) -> Dict:
        """Run WhatWeb for technology detection"""
        try:
            protocol = 'https' if port == 443 else 'http'
            url = f"{protocol}://{target}:{port}"
            
            cmd = f"whatweb --color=never --log-json={self.temp_dir}/whatweb.json {url}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0 and os.path.exists(f"{self.temp_dir}/whatweb.json"):
                with open(f"{self.temp_dir}/whatweb.json", 'r') as f:
                    whatweb_data = json.load(f)
                    return whatweb_data
                    
        except Exception as e:
            print(f"WhatWeb scan failed: {e}")
            
        return {}

    def check_technology_vulnerabilities(self, whatweb_info: Dict) -> List[Dict]:
        """Check for vulnerabilities in detected technologies"""
        vulnerabilities = []
        
        try:
            # Extract technologies from WhatWeb output
            technologies = []
            if isinstance(whatweb_info, list) and whatweb_info:
                target_info = whatweb_info[0]
                plugins = target_info.get('plugins', {})
                
                for plugin, info in plugins.items():
                    if plugin not in ['HTTPServer', 'IP']:
                        version = info.get('version', [''])[0] if info.get('version') else ''
                        technologies.append({
                            'name': plugin,
                            'version': version
                        })
            
            # Check each technology for known vulnerabilities
            for tech in technologies:
                tech_vulns = self.lookup_technology_vulnerabilities(tech['name'], tech['version'])
                vulnerabilities.extend(tech_vulns)
                
        except Exception as e:
            print(f"Technology vulnerability check failed: {e}")
            
        return vulnerabilities

    def lookup_technology_vulnerabilities(self, technology: str, version: str) -> List[Dict]:
        """Look up known vulnerabilities for a technology"""
        vulnerabilities = []
        
        try:
            # This would integrate with CVE databases or local vulnerability databases
            # For now, we'll check some common technologies with known issues
            
            common_vulnerabilities = {
                'Apache': [
                    {'cve': 'CVE-2021-41773', 'description': 'Path Traversal in Apache HTTP Server', 'severity': 'HIGH'},
                    {'cve': 'CVE-2021-42013', 'description': 'RCE in Apache HTTP Server', 'severity': 'CRITICAL'}
                ],
                'nginx': [
                    {'cve': 'CVE-2021-23017', 'description': 'DNS resolver vulnerability', 'severity': 'MEDIUM'}
                ],
                'WordPress': [
                    {'cve': 'CVE-2022-21661', 'description': 'SQL Injection vulnerability', 'severity': 'HIGH'},
                    {'cve': 'CVE-2022-21664', 'description': 'XSS vulnerability', 'severity': 'MEDIUM'}
                ],
                'PHP': [
                    {'cve': 'CVE-2022-31626', 'description': 'PHP vulnerability', 'severity': 'HIGH'}
                ]
            }
            
            tech_lower = technology.lower()
            for tech_name, vulns in common_vulnerabilities.items():
                if tech_name.lower() in tech_lower:
                    for vuln in vulns:
                        vulnerabilities.append({
                            'type': 'KNOWN_CVE',
                            'severity': vuln['severity'],
                            'description': vuln['description'],
                            'recommendation': f'Apply patches for {vuln["cve"]}',
                            'evidence': f'Detected {technology} {version} - {vuln["cve"]}',
                            'cve_id': vuln['cve'],
                            'source': 'cve_database'
                        })
                        
        except Exception as e:
            print(f"Technology vulnerability lookup failed: {e}")
            
        return vulnerabilities

    # SSL/TLS Scanning with testssl.sh
    def perform_ssl_analysis(self, target: str, config: Dict) -> Dict:
        """Perform comprehensive SSL/TLS analysis with robust error handling"""
        vulnerabilities = []
        certificate_info = {}
        protocol_info = {}
        
        try:
            # Extract hostname safely
            if '://' in target:
                hostname = target.split('://')[-1].split('/')[0].split(':')[0]
            else:
                hostname = target.split('/')[0].split(':')[0]
            
            port = 443  # Default SSL port
            
            print(f"ðŸ”’ Starting SSL analysis for {hostname}:{port}")
            
            # Get certificate info with timeout
            cert_info = self.get_certificate_info(hostname, port)
            if cert_info and 'error' not in cert_info:
                certificate_info = cert_info
                cert_vulns = self.check_certificate_vulnerabilities(cert_info)
                vulnerabilities.extend(cert_vulns)
            else:
                error_msg = cert_info.get('error', 'Unknown error') if cert_info else 'No certificate info'
                print(f"âš ï¸  Could not retrieve certificate info: {error_msg}")
                vulnerabilities.append({
                    'type': 'CERTIFICATE_RETRIEVAL_FAILED',
                    'severity': 'MEDIUM',
                    'description': f'Could not retrieve SSL certificate for {hostname}:{port}',
                    'recommendation': 'Check if the service supports SSL/TLS and is accessible',
                    'evidence': f'Error: {error_msg}',
                    'source': 'ssl_analysis'
                })
            
            # Check protocol support
            try:
                proto_info = self.check_protocol_support(hostname, port)
                protocol_info = proto_info
                vulnerabilities.extend(proto_info.get('vulnerabilities', []))
            except Exception as e:
                print(f"Protocol support check failed: {e}")
            
            # Check cipher strength if testssl is available
            if self._check_command('testssl.sh --version'):
                try:
                    cipher_vulns = self.check_cipher_strength(hostname, port)
                    vulnerabilities.extend(cipher_vulns)
                except Exception as e:
                    print(f"Cipher strength check failed: {e}")
            
        except Exception as e:
            print(f"âŒ SSL analysis failed: {e}")
            vulnerabilities.append({
                'type': 'SSL_SCAN_ERROR',
                'severity': 'MEDIUM',
                'description': f'SSL analysis failed: {str(e)}',
                'recommendation': 'Check if target supports SSL/TLS and is accessible',
                'source': 'ssl_analysis'
            })
        
        # Calculate security score safely
        try:
            security_score = self.calculate_ssl_security_score(vulnerabilities, certificate_info, protocol_info)
        except Exception as e:
            print(f"Security score calculation failed: {e}")
            security_score = 0
        
        return {
            'certificate_info': certificate_info,
            'protocol_info': protocol_info,
            'vulnerabilities': vulnerabilities,
            'security_score': security_score
        }

    def run_testssl_scan(self, target: str) -> Dict:
        """Run testssl.sh for comprehensive SSL testing"""
        try:
            hostname = target.split('://')[-1].split('/')[0].split(':')[0]
            
            cmd = f"testssl.sh --jsonfile {self.temp_dir}/testssl.json {hostname}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0 and os.path.exists(f"{self.temp_dir}/testssl.json"):
                with open(f"{self.temp_dir}/testssl.json", 'r') as f:
                    testssl_data = json.load(f)
                    return self.parse_testssl_output(testssl_data)
                    
        except Exception as e:
            print(f"testssl.sh scan failed: {e}")
            
        return {}

    def parse_testssl_output(self, testssl_data: Dict) -> Dict:
        """Parse testssl.sh JSON output"""
        vulnerabilities = []
        certificate_info = {}
        protocol_info = {
            'supported_protocols': {},
            'weak_protocols_enabled': False,
            'recommended_protocols': ['TLSv1.2', 'TLSv1.3']
        }
        
        try:
            for scan in testssl_data.get('scanResult', []):
                id = scan.get('id', '')
                finding = scan.get('finding', '')
                severity = scan.get('severity', 'INFO')
                
                if severity in ['MEDIUM', 'HIGH', 'CRITICAL']:
                    vulnerabilities.append({
                        'type': f'SSL_{id.upper()}',
                        'severity': self.map_testssl_severity(severity),
                        'description': finding,
                        'recommendation': self.get_ssl_recommendation(id),
                        'evidence': finding,
                        'source': 'testssl.sh'
                    })
                
                # Extract certificate information
                if 'certificate' in id.lower():
                    certificate_info = self.extract_certificate_info(scan)
                
                # Extract protocol information
                if 'protocol' in id.lower():
                    protocol_name = id.replace('_', ' ').title()
                    protocol_info['supported_protocols'][protocol_name] = 'OK' in finding
                    
        except Exception as e:
            print(f"testssl output parsing failed: {e}")
            
        protocol_info['weak_protocols_enabled'] = any(
            proto in protocol_info['supported_protocols'] 
            for proto in ['SSL 2', 'SSL 3', 'TLS 1.0', 'TLS 1.1']
        )
        
        return {
            'certificate_info': certificate_info,
            'protocol_info': protocol_info,
            'vulnerabilities': vulnerabilities
        }

    def map_testssl_severity(self, severity: str) -> str:
        """Map testssl.sh severity to our system"""
        mapping = {
            'LOW': 'LOW',
            'MEDIUM': 'MEDIUM', 
            'HIGH': 'HIGH',
            'CRITICAL': 'CRITICAL'
        }
        return mapping.get(severity, 'MEDIUM')

    def get_ssl_recommendation(self, test_id: str) -> str:
        """Get recommendation for SSL finding"""
        recommendations = {
            'ssl_2': 'Disable SSL 2.0 immediately',
            'ssl_3': 'Disable SSL 3.0',
            'tls_1_0': 'Disable TLS 1.0',
            'tls_1_1': 'Disable TLS 1.1',
            'cipherlist_medium': 'Use stronger cipher suites',
            'cipherlist_low': 'Remove weak cipher suites immediately',
            'certificate_expired': 'Renew SSL certificate',
            'certificate_soon': 'Renew SSL certificate before expiration'
        }
        return recommendations.get(test_id, 'Review and fix SSL/TLS configuration')

    # Web Application Scanning
    def perform_web_security_scan(self, target: str, config: Dict) -> Dict:
        """Perform comprehensive web security scanning"""
        vulnerabilities = []
        
        try:
            # Headers security analysis
            headers_vulns = self.analyze_http_headers(target)
            vulnerabilities.extend(headers_vulns)
            
            # Directory and file enumeration
            if config.get('directory_enum', True):
                dir_vulns = self.perform_directory_enumeration(target)
                vulnerabilities.extend(dir_vulns)
            
            # SSL/TLS analysis for web
            ssl_vulns = self.analyze_web_ssl(target)
            vulnerabilities.extend(ssl_vulns)
            
            # Security headers check
            security_headers_vulns = self.check_security_headers(target)
            vulnerabilities.extend(security_headers_vulns)
            
            # Cookie security analysis
            cookie_vulns = self.analyze_cookie_security(target)
            vulnerabilities.extend(cookie_vulns)
            
            # Run nuclei for template-based scanning
            nuclei_vulns = self.run_nuclei_scan(target)
            vulnerabilities.extend(nuclei_vulns)
            
        except Exception as e:
            print(f"Web security scan failed: {e}")
            vulnerabilities.append({
                'type': 'SCAN_ERROR',
                'severity': 'MEDIUM',
                'description': f'Web security scan failed: {str(e)}',
                'recommendation': 'Check target accessibility and network connectivity'
            })
        
        risk_assessment = self.calculate_web_risk_assessment(vulnerabilities)
        
        return {
            'vulnerabilities': vulnerabilities,
            'risk_assessment': risk_assessment
        }

    def run_nuclei_scan(self, target: str) -> List[Dict]:
        """Run nuclei vulnerability scanner"""
        vulnerabilities = []
        
        try:
            cmd = f"nuclei -u {target} -json -o {self.temp_dir}/nuclei.json"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=600)
            
            if result.returncode == 0 and os.path.exists(f"{self.temp_dir}/nuclei.json"):
                with open(f"{self.temp_dir}/nuclei.json", 'r') as f:
                    for line in f:
                        if line.strip():
                            nuclei_finding = json.loads(line)
                            vuln = self.parse_nuclei_finding(nuclei_finding)
                            vulnerabilities.append(vuln)
                            
        except Exception as e:
            print(f"Nuclei scan failed: {e}")
            
        return vulnerabilities

    def parse_nuclei_finding(self, finding: Dict) -> Dict:
        """Parse nuclei finding"""
        return {
            'type': f"NUCLEI_{finding.get('templateID', 'FINDING')}",
            'severity': finding.get('info', {}).get('severity', 'MEDIUM').upper(),
            'description': finding.get('info', {}).get('description', ''),
            'recommendation': 'Review and fix the identified vulnerability',
            'evidence': finding.get('matched-at', ''),
            'source': 'nuclei'
        }

    def perform_directory_enumeration(self, target: str) -> List[Dict]:
        """Perform directory enumeration using dirb and custom wordlists"""
        vulnerabilities = []
        
        try:
            # Use dirb for directory enumeration
            cmd = f"dirb {target} -o {self.temp_dir}/dirb.txt"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=300)
            
            if os.path.exists(f"{self.temp_dir}/dirb.txt"):
                with open(f"{self.temp_dir}/dirb.txt", 'r') as f:
                    for line in f:
                        if 'CODE:' in line and any(code in line for code in ['200', '301', '302', '403']):
                            parts = line.split()
                            if len(parts) >= 2:
                                path = parts[0]
                                code = parts[1].replace('CODE:', '')
                                
                                vulnerabilities.append({
                                    'type': 'SENSITIVE_PATH_EXPOSED',
                                    'severity': 'LOW' if code == '403' else 'MEDIUM',
                                    'description': f'Sensitive path accessible: {path}',
                                    'recommendation': f'Restrict access to {path} or remove if not needed',
                                    'evidence': f'Path {path} returned status {code}',
                                    'source': 'dirb'
                                })
                                
        except Exception as e:
            print(f"Directory enumeration failed: {e}")
            
        return vulnerabilities

    # Helper methods for the original functions
    def analyze_http_headers(self, target: str) -> List[Dict]:
        """Analyze HTTP headers with better network error handling"""
        vulnerabilities = []
        
        try:
            response = requests.get(target, timeout=10, verify=False)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'Content-Security-Policy': 'MEDIUM',
                'X-Content-Type-Options': 'LOW',
                'X-Frame-Options': 'MEDIUM',
                'Strict-Transport-Security': 'HIGH',
                'X-XSS-Protection': 'LOW'
            }
            
            for header, severity in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'MISSING_SECURITY_HEADER',
                        'severity': severity,
                        'description': f'Missing security header: {header}',
                        'recommendation': f'Implement {header} header with appropriate values',
                        'evidence': f'Header {header} not found in response',
                        'source': 'header_analysis'
                    })
            
            # Check for information disclosure
            if 'Server' in headers and len(headers['Server']) > 0:
                vulnerabilities.append({
                    'type': 'INFORMATION_DISCLOSURE',
                    'severity': 'LOW',
                    'description': f'Server information disclosed: {headers["Server"]}',
                    'recommendation': 'Minimize server header information',
                    'evidence': f'Server: {headers["Server"]}',
                    'source': 'header_analysis'
                })
                
        except requests.exceptions.ConnectTimeout:
            vulnerabilities.append({
                'type': 'CONNECTION_TIMEOUT',
                'severity': 'MEDIUM',
                'description': f'Connection to {target} timed out',
                'recommendation': 'Check target accessibility and network connectivity',
                'source': 'header_analysis'
            })
        except requests.exceptions.ConnectionError:
            vulnerabilities.append({
                'type': 'CONNECTION_REFUSED',
                'severity': 'MEDIUM',
                'description': f'Connection to {target} refused',
                'recommendation': 'Target may be down or blocking connections',
                'source': 'header_analysis'
            })
        except Exception as e:
            vulnerabilities.append({
                'type': 'HEADER_ANALYSIS_ERROR',
                'severity': 'MEDIUM',
                'description': f'Header analysis failed: {str(e)}',
                'recommendation': 'Check target accessibility',
                'source': 'header_analysis'
            })
        
        return vulnerabilities

    def check_security_headers(self, target: str) -> List[Dict]:
        """Check security headers configuration"""
        vulnerabilities = []
        
        try:
            response = requests.get(target, timeout=10, verify=False)
            headers = response.headers
            
            # Analyze HSTS configuration
            if 'Strict-Transport-Security' in headers:
                hsts = headers['Strict-Transport-Security']
                if 'max-age=0' in hsts:
                    vulnerabilities.append({
                        'type': 'HSTS_MISCONFIGURATION',
                        'severity': 'HIGH',
                        'description': 'HSTS max-age set to 0, disabling protection',
                        'recommendation': 'Set appropriate max-age value (e.g., 31536000)',
                        'evidence': f'HSTS Header: {hsts}',
                        'source': 'header_analysis'
                    })
            
            # Check CSP for unsafe directives
            if 'Content-Security-Policy' in headers:
                csp = headers['Content-Security-Policy']
                if 'unsafe-inline' in csp or 'unsafe-eval' in csp:
                    vulnerabilities.append({
                        'type': 'CSP_UNSAFE_DIRECTIVES',
                        'severity': 'MEDIUM',
                        'description': 'CSP contains unsafe directives',
                        'recommendation': 'Remove unsafe-inline and unsafe-eval from CSP',
                        'evidence': f'CSP: {csp}',
                        'source': 'header_analysis'
                    })
                    
        except Exception as e:
            # Error already handled in analyze_http_headers
            pass
        
        return vulnerabilities

    def analyze_cookie_security(self, target: str) -> List[Dict]:
        """Analyze cookie security settings"""
        vulnerabilities = []
        
        try:
            response = requests.get(target, timeout=10, verify=False)
            cookies = response.cookies
            
            for cookie in cookies:
                cookie_issues = []
                
                if not cookie.secure:
                    cookie_issues.append('Secure flag missing')
                
                if not cookie.has_nonstandard_attr('HttpOnly'):
                    cookie_issues.append('HttpOnly flag missing')
                
                if cookie_issues:
                    vulnerabilities.append({
                        'type': 'INSECURE_COOKIE',
                        'severity': 'MEDIUM',
                        'description': f'Insecure cookie: {cookie.name}',
                        'recommendation': 'Set Secure and HttpOnly flags on cookies',
                        'evidence': f'Cookie {cookie.name}: {", ".join(cookie_issues)}',
                        'source': 'cookie_analysis'
                    })
                    
        except Exception as e:
            print(f"Cookie analysis failed: {e}")
            
        return vulnerabilities

    def analyze_web_ssl(self, target: str) -> List[Dict]:
        """Analyze web SSL configuration"""
        vulnerabilities = []
        
        try:
            hostname = target.split('://')[-1].split('/')[0].split(':')[0]
            cert_info = self.get_certificate_info(hostname, 443)
            
            if cert_info and 'error' not in cert_info:
                cert_vulns = self.check_certificate_vulnerabilities(cert_info)
                vulnerabilities.extend(cert_vulns)
                
        except Exception as e:
            print(f"Web SSL analysis failed: {e}")
            
        return vulnerabilities

    def get_certificate_info(self, hostname: str, port: int) -> Dict:
        """Get SSL certificate information"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cert_bin = ssock.getpeercert(binary_form=True)
                    
                    x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_ASN1, cert_bin)
                    issuer = dict(x509.get_issuer().get_components())
                    subject = dict(x509.get_subject().get_components())
                    
                    not_before = x509.get_notBefore().decode('ascii')
                    not_after = x509.get_notAfter().decode('ascii')
                    
                    # Parse dates
                    from datetime import datetime
                    not_before_dt = datetime.strptime(not_before, '%Y%m%d%H%M%SZ')
                    not_after_dt = datetime.strptime(not_after, '%Y%m%d%H%M%SZ')
                    
                    # Calculate days until expiry safely
                    now = datetime.utcnow()
                    days_until_expiry = (not_after_dt - now).days
                    has_expired = now > not_after_dt
                    
                    return {
                        'subject': {k.decode(): v.decode() for k, v in subject.items()},
                        'issuer': {k.decode(): v.decode() for k, v in issuer.items()},
                        'not_before': not_before_dt.isoformat(),
                        'not_after': not_after_dt.isoformat(),
                        'has_expired': has_expired,
                        'days_until_expiry': days_until_expiry,
                        'signature_algorithm': x509.get_signature_algorithm().decode('ascii')
                    }
                    
        except Exception as e:
            print(f"Certificate info error for {hostname}:{port}: {e}")
            return {'error': str(e)}

    def check_certificate_vulnerabilities(self, cert_info: Dict) -> List[Dict]:
        """Check certificate for vulnerabilities with proper error handling"""
        vulnerabilities = []
        
        # Check if certificate info is valid and has no errors
        if not cert_info or 'error' in cert_info:
            error_msg = cert_info.get('error', 'Unknown error') if cert_info else 'No certificate data'
            return [{
                'type': 'CERTIFICATE_ERROR',
                'severity': 'MEDIUM',
                'description': f'Certificate retrieval failed: {error_msg}',
                'recommendation': 'Check if SSL/TLS service is running and accessible',
                'evidence': f'Error: {error_msg}',
                'source': 'ssl_analysis'
            }]
        
        # Safely check expiration with proper field validation
        has_expired = cert_info.get('has_expired', False)
        days_until_expiry = cert_info.get('days_until_expiry', 0)  # Use get() with default
        
        # Only check expiration if we have valid data
        if has_expired:
            vulnerabilities.append({
                'type': 'EXPIRED_CERTIFICATE',
                'severity': 'HIGH',
                'description': 'SSL certificate has expired',
                'recommendation': 'Renew SSL certificate immediately',
                'evidence': f'Certificate expired on {cert_info.get("not_after", "unknown date")}',
                'source': 'ssl_analysis'
            })
        elif days_until_expiry > 0 and days_until_expiry < 30:  # Added > 0 check
            vulnerabilities.append({
                'type': 'CERTIFICATE_EXPIRING_SOON',
                'severity': 'MEDIUM',
                'description': f'SSL certificate expires in {days_until_expiry} days',
                'recommendation': 'Renew SSL certificate',
                'evidence': f'Certificate expires on {cert_info.get("not_after", "unknown date")}',
                'source': 'ssl_analysis'
            })
        
        # Check signature algorithm safely
        sig_algo = cert_info.get('signature_algorithm', '')
        weak_algorithms = ['md5', 'sha1']
        if sig_algo and any(algo in sig_algo.lower() for algo in weak_algorithms):
            vulnerabilities.append({
                'type': 'WEAK_CERTIFICATE_SIGNATURE',
                'severity': 'HIGH',
                'description': f'Weak certificate signature algorithm: {sig_algo}',
                'recommendation': 'Use stronger signature algorithm (SHA-256 or higher)',
                'evidence': f'Signature algorithm: {sig_algo}',
                'source': 'ssl_analysis'
            })
        
        return vulnerabilities

    def check_protocol_support(self, hostname: str, port: int) -> Dict:
        """Check supported SSL/TLS protocols"""
        protocols = {
            'SSLv2': False,
            'SSLv3': False, 
            'TLSv1.0': False,
            'TLSv1.1': False,
            'TLSv1.2': False,
            'TLSv1.3': False
        }
        
        vulnerabilities = []
        
        # Test protocols (simplified - in practice use more robust methods)
        for protocol_name in ['TLSv1.2', 'TLSv1.3']:  # Focus on common ones
            try:
                context = ssl.SSLContext(getattr(ssl, f'PROTOCOL_{protocol_name.upper().replace("V", "_")}'))
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                
                with socket.create_connection((hostname, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        protocols[protocol_name] = True
                        
            except Exception:
                protocols[protocol_name] = False
        
        # Check for weak protocols (based on common knowledge)
        if any(protocols.get(p, False) for p in ['SSLv2', 'SSLv3', 'TLSv1.0', 'TLSv1.1']):
            vulnerabilities.append({
                'type': 'WEAK_SSL_PROTOCOL',
                'severity': 'HIGH',
                'description': 'Weak SSL protocol enabled (SSLv2/SSLv3/TLS1.0/TLS1.1)',
                'recommendation': 'Disable weak protocols, use TLS 1.2 or higher',
                'evidence': f'Enabled protocols: {[k for k, v in protocols.items() if v]}',
                'source': 'ssl_analysis'
            })
        
        return {
            'supported_protocols': protocols,
            'weak_protocols_enabled': any(protocols.get(p, False) for p in ['SSLv2', 'SSLv3', 'TLSv1.0', 'TLSv1.1']),
            'recommended_protocols': ['TLSv1.2', 'TLSv1.3'],
            'vulnerabilities': vulnerabilities
        }

    def extract_certificate_info(self, scan: Dict) -> Dict:
        """Extract certificate information from testssl scan"""
        # Implementation for extracting cert info from testssl
        return {}

    def extract_cve_from_output(self, output: str) -> str:
        """Extract CVE ID from tool output"""
        cve_pattern = r'CVE-\d{4}-\d{4,}'
        matches = re.findall(cve_pattern, output)
        return matches[0] if matches else None

    def determine_nmap_severity(self, output: str) -> str:
        """Determine severity from nmap script output"""
        output_lower = output.lower()
        if 'critical' in output_lower:
            return 'CRITICAL'
        elif 'high' in output_lower:
            return 'HIGH'
        elif 'medium' in output_lower:
            return 'MEDIUM'
        else:
            return 'LOW'

    # Risk Assessment Methods
    def calculate_web_risk_assessment(self, vulnerabilities: List[Dict]) -> Dict:
        """Calculate risk assessment for web security findings"""
        severity_weights = {
            'CRITICAL': 10,
            'HIGH': 7,
            'MEDIUM': 4,
            'LOW': 1
        }
        
        risk_score = sum(severity_weights.get(vuln.get('severity', 'LOW'), 1) for vuln in vulnerabilities)
        
        # Normalize score (0-100)
        max_possible_score = len(vulnerabilities) * 10
        normalized_score = min(100, (risk_score / max(1, max_possible_score)) * 100) if max_possible_score > 0 else 0
        
        severity_counts = {
            'CRITICAL': len([v for v in vulnerabilities if v.get('severity') == 'CRITICAL']),
            'HIGH': len([v for v in vulnerabilities if v.get('severity') == 'HIGH']),
            'MEDIUM': len([v for v in vulnerabilities if v.get('severity') == 'MEDIUM']),
            'LOW': len([v for v in vulnerabilities if v.get('severity') == 'LOW'])
        }
        
        total_vulnerabilities = len(vulnerabilities)
        
        # Determine risk level
        if severity_counts['CRITICAL'] > 0 or severity_counts['HIGH'] > 2:
            risk_level = 'CRITICAL'
        elif severity_counts['HIGH'] > 0 or severity_counts['MEDIUM'] > 3:
            risk_level = 'HIGH'
        elif severity_counts['MEDIUM'] > 1 or total_vulnerabilities > 5:
            risk_level = 'MEDIUM'
        elif total_vulnerabilities > 0:
            risk_level = 'LOW'
        else:
            risk_level = 'NONE'
        
        return {
            'risk_score': normalized_score,
            'risk_level': risk_level,
            'critical_count': severity_counts['CRITICAL'],
            'high_count': severity_counts['HIGH'],
            'medium_count': severity_counts['MEDIUM'],
            'low_count': severity_counts['LOW'],
            'total_vulnerabilities': total_vulnerabilities
        }

    def calculate_service_risk_assessment(self, vulnerabilities: List[Dict]) -> Dict:
        """Calculate risk assessment for service vulnerabilities"""
        return self.calculate_web_risk_assessment(vulnerabilities)

    def calculate_ssl_security_score(self, vulnerabilities: List[Dict], certificate_info: Dict, protocol_info: Dict) -> int:
        """Calculate SSL security score with safe field access"""
        base_score = 100
        
        # Deduct for vulnerabilities
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'LOW')
            if severity == 'CRITICAL':
                base_score -= 30
            elif severity == 'HIGH':
                base_score -= 20
            elif severity == 'MEDIUM':
                base_score -= 10
            elif severity == 'LOW':
                base_score -= 5
        
        # Certificate-related deductions (only if certificate_info is valid)
        if certificate_info and 'error' not in certificate_info:
            has_expired = certificate_info.get('has_expired', False)
            days_until_expiry = certificate_info.get('days_until_expiry', 0)
            
            if has_expired:
                base_score -= 30
            elif days_until_expiry > 0 and days_until_expiry < 7:
                base_score -= 20
            elif days_until_expiry > 0 and days_until_expiry < 30:
                base_score -= 10
                
            # Check certificate signature strength
            sig_algo = certificate_info.get('signature_algorithm', '').lower()
            if 'sha1' in sig_algo:
                base_score -= 15
            elif 'md5' in sig_algo:
                base_score -= 25
        
        # Protocol-related deductions
        if protocol_info:
            supported_protocols = protocol_info.get('supported_protocols', {})
            
            # Deduct for weak protocols
            if supported_protocols.get('SSLv2', False):
                base_score -= 20
            if supported_protocols.get('SSLv3', False):
                base_score -= 15
            if supported_protocols.get('TLSv1.0', False):
                base_score -= 10
            if supported_protocols.get('TLSv1.1', False):
                base_score -= 5
                
            # Bonus for strong protocols
            if supported_protocols.get('TLSv1.3', False):
                base_score += 5
            if supported_protocols.get('TLSv1.2', False) and not supported_protocols.get('TLSv1.3', False):
                base_score += 2
        
        return max(0, min(100, base_score))

    def calculate_overall_risk(self, results: Dict) -> Dict:
        """Calculate overall risk assessment"""
        component_scores = {}
        
        if results.get('web_security'):
            component_scores['web_security'] = results['web_security']['risk_assessment']['risk_score']
        
        if results.get('ssl_security'):
            component_scores['ssl_security'] = results['ssl_security']['security_score']
        
        if results.get('cve_analysis'):
            # Calculate score based on CVE findings
            cve_results = results['cve_analysis']
            total_vulns = cve_results['summary']['total_vulnerabilities']
            component_scores['cve_analysis'] = min(100, total_vulns * 10)
        
        # Calculate weighted overall score
        weights = {
            'web_security': 0.4,
            'ssl_security': 0.3,
            'cve_analysis': 0.3
        }
        
        overall_score = 0
        for component, score in component_scores.items():
            overall_score += score * weights.get(component, 0)
        
        # Determine overall risk level
        if overall_score >= 80:
            risk_level = 'CRITICAL'
        elif overall_score >= 60:
            risk_level = 'HIGH'
        elif overall_score >= 40:
            risk_level = 'MEDIUM'
        elif overall_score >= 20:
            risk_level = 'LOW'
        else:
            risk_level = 'NONE'
        
        return {
            'overall_score': overall_score,
            'risk_level': risk_level,
            'component_scores': component_scores
        }

    # Credential Testing (Safe Implementation)
    def perform_credential_testing(self, target: str, config: Dict) -> Dict:
        """Perform safe credential testing with authorization"""
        service_type = config.get('service_type', 'ssh')
        port = config.get('port', self.get_default_port(service_type))
        
        # This should only be used with explicit authorization and safe test credentials
        # In a real implementation, this would integrate with tools like hydra or medusa
        # but with strict controls and safe defaults
        
        return {
            'service': service_type,
            'host': target,
            'port': port,
            'credentials_tested': 0,  # Would be actual count from testing
            'vulnerable_credentials': [],  # Would contain actual results
            'recommendations': [
                'Implement strong password policies',
                'Enable multi-factor authentication',
                'Use certificate-based authentication where possible',
                'Implement account lockout policies',
                'Regularly review and remove default accounts'
            ]
        }

    def get_default_port(self, service_type: str) -> int:
        """Get default port for service type"""
        ports = {
            'ssh': 22,
            'ftp': 21,
            'mysql': 3306,
            'telnet': 23,
            'postgresql': 5432,
            'rdp': 3389
        }
        return ports.get(service_type, 22)

    def scan_auth_vulnerabilities(self, target: str, port: int, service_name: str) -> List[Dict]:
        """Scan authentication service vulnerabilities"""
        vulnerabilities = []
        
        try:
            print(f"ðŸ” Scanning {service_name} authentication vulnerabilities on {target}:{port}")
            
            if service_name == 'ssh':
                vulns = self.scan_ssh_vulnerabilities(target, port, '')
                vulnerabilities.extend(vulns)
            elif service_name == 'ftp':
                vulns = self.scan_ftp_vulnerabilities(target, port, '')
                vulnerabilities.extend(vulns)
            elif service_name == 'telnet':
                vulns = self.scan_telnet_vulnerabilities(target, port)
                vulnerabilities.extend(vulns)
                
            # Check for default credentials (information only)
            default_creds = self.get_default_credentials(service_name)
            if default_creds:
                vulnerabilities.append({
                    'type': 'DEFAULT_CREDENTIALS_INFO',
                    'severity': 'MEDIUM',
                    'description': f'Service {service_name} has known default credentials',
                    'recommendation': 'Change default credentials and implement strong authentication',
                    'evidence': f'Known default credentials exist for {service_name}',
                    'source': 'credential_analysis'
                })
                
        except Exception as e:
            print(f"Auth vulnerability scan failed for {service_name}: {e}")
        
        return vulnerabilities

    def get_default_credentials(self, service: str) -> List[Dict]:
        """Get known default credentials (for informational purposes only)"""
        default_creds = {
            'ssh': [{'username': 'root', 'password': 'root'}, {'username': 'admin', 'password': 'admin'}],
            'ftp': [{'username': 'anonymous', 'password': ''}, {'username': 'ftp', 'password': 'ftp'}],
            'telnet': [{'username': 'root', 'password': ''}],
            'mysql': [{'username': 'root', 'password': ''}]
        }
        return default_creds.get(service, [])

    def scan_database_vulnerabilities(self, target: str, port: int, service_name: str) -> List[Dict]:
        """Scan database service vulnerabilities"""
        vulnerabilities = []
        
        try:
            print(f"ðŸ—„ï¸ Scanning {service_name} database vulnerabilities on {target}:{port}")
            
            # Run nmap database vulnerability scripts
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script {service_name}-*')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        for script_name, script_output in scripts.items():
                            if any(keyword in script_name.lower() for keyword in ['vuln', 'auth', 'brute']):
                                vulnerabilities.append({
                                    'type': f'DATABASE_{script_name.upper()}',
                                    'severity': 'MEDIUM',
                                    'description': f'Database vulnerability detected: {script_name}',
                                    'recommendation': f'Secure {service_name} configuration and apply patches',
                                    'evidence': script_output,
                                    'source': 'database_scan'
                                })
            
            # Add database-specific checks
            if service_name == 'mysql':
                vulnerabilities.extend(self.check_mysql_vulnerabilities(target, port))
            elif service_name == 'postgresql':
                vulnerabilities.extend(self.check_postgresql_vulnerabilities(target, port))
                
        except Exception as e:
            print(f"Database vulnerability scan failed for {service_name}: {e}")
        
        return vulnerabilities

    def __del__(self):
        """Cleanup temporary files"""
        import shutil
        try:
            shutil.rmtree(self.temp_dir)
        except:
            pass

    def check_mysql_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Check MySQL-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for empty root password
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script mysql-empty-password')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        if 'mysql-empty-password' in scripts:
                            vulnerabilities.append({
                                'type': 'MYSQL_EMPTY_PASSWORD',
                                'severity': 'HIGH',
                                'description': 'MySQL allows empty root password',
                                'recommendation': 'Set strong password for MySQL root account',
                                'evidence': scripts['mysql-empty-password'],
                                'source': 'mysql_scan'
                            })
                            
        except Exception as e:
            print(f"MySQL vulnerability check failed: {e}")
        
        return vulnerabilities

    def check_postgresql_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Check PostgreSQL-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for trust authentication
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script pgsql-brute')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        if 'pgsql-brute' in scripts and 'Valid credentials' in scripts['pgsql-brute']:
                            vulnerabilities.append({
                                'type': 'POSTGRES_WEAK_AUTH',
                                'severity': 'MEDIUM',
                                'description': 'PostgreSQL may have weak authentication',
                                'recommendation': 'Implement strong authentication and use md5 or scram-sha-256',
                                'evidence': scripts['pgsql-brute'],
                                'source': 'postgres_scan'
                            })
                            
        except Exception as e:
            print(f"PostgreSQL vulnerability check failed: {e}")
        
        return vulnerabilities

    # Add these methods to the VulnerabilityScanner class

    def calculate_service_risk_assessment(self, vulnerabilities: List[Dict]) -> Dict:
        """Calculate risk assessment for service vulnerabilities"""
        return self.calculate_web_risk_assessment(vulnerabilities)

    def check_service_vulnerabilities(self, service: Dict, target: str) -> List[Dict]:
        """Check for service-specific vulnerabilities using multiple methods"""
        vulnerabilities = []
        
        try:
            service_name = service['name'].lower()
            port = service['port']
            version = service.get('version', '')
            
            # Service-specific vulnerability checks
            if service_name in ['http', 'https', 'http-alt']:
                vulns = self.scan_web_vulnerabilities(target, port)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['ssh']:
                vulns = self.scan_ssh_vulnerabilities(target, port, version)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['ftp']:
                vulns = self.scan_ftp_vulnerabilities(target, port, version)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['telnet']:
                vulns = self.scan_telnet_vulnerabilities(target, port)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['mysql', 'postgresql', 'oracle-db', 'microsoft-ds']:
                vulns = self.scan_database_vulnerabilities(target, port, service_name)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['smb', 'netbios-ssn']:
                vulns = self.scan_smb_vulnerabilities(target, port)
                vulnerabilities.extend(vulns)
                
            elif service_name in ['rdp']:
                vulns = self.scan_rdp_vulnerabilities(target, port)
                vulnerabilities.extend(vulns)
            
            # General service vulnerability checks
            general_vulns = self.check_general_service_vulnerabilities(service, target)
            vulnerabilities.extend(general_vulns)
            
            # Version-specific vulnerability checks
            if version:
                version_vulns = self.check_version_vulnerabilities(service_name, version)
                vulnerabilities.extend(version_vulns)
                
        except Exception as e:
            print(f"Service vulnerability check failed for {service['name']}: {e}")
            
        return vulnerabilities

    def calculate_ssl_security_score(self, vulnerabilities: List[Dict], certificate_info: Dict, protocol_info: Dict) -> int:
        """Calculate comprehensive SSL security score (0-100)"""
        base_score = 100
        
        # Deduct for vulnerabilities based on severity
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'LOW')
            if severity == 'CRITICAL':
                base_score -= 25
            elif severity == 'HIGH':
                base_score -= 15
            elif severity == 'MEDIUM':
                base_score -= 8
            elif severity == 'LOW':
                base_score -= 3
        
        # Certificate-related deductions
        if certificate_info:
            if certificate_info.get('has_expired', False):
                base_score -= 30
            elif certificate_info.get('days_until_expiry', 0) < 7:
                base_score -= 20
            elif certificate_info.get('days_until_expiry', 0) < 30:
                base_score -= 10
                
            # Check certificate signature strength
            sig_algo = certificate_info.get('signature_algorithm', '').lower()
            if 'sha1' in sig_algo:
                base_score -= 15
            elif 'md5' in sig_algo:
                base_score -= 25
        
        # Protocol-related deductions
        if protocol_info:
            supported_protocols = protocol_info.get('supported_protocols', {})
            
            # Deduct for weak protocols
            if supported_protocols.get('SSLv2', False):
                base_score -= 20
            if supported_protocols.get('SSLv3', False):
                base_score -= 15
            if supported_protocols.get('TLSv1.0', False):
                base_score -= 10
            if supported_protocols.get('TLSv1.1', False):
                base_score -= 5
                
            # Bonus for strong protocols
            if supported_protocols.get('TLSv1.3', False):
                base_score += 5
            if supported_protocols.get('TLSv1.2', False) and not supported_protocols.get('TLSv1.3', False):
                base_score += 2
        
        # Cipher strength deductions (if we have cipher info)
        cipher_vulns = [v for v in vulnerabilities if 'CIPHER' in v.get('type', '')]
        for cipher_vuln in cipher_vulns:
            if cipher_vuln.get('severity') == 'HIGH':
                base_score -= 12
            elif cipher_vuln.get('severity') == 'MEDIUM':
                base_score -= 6
        
        return max(0, min(100, base_score))

    def check_cipher_strength(self, hostname: str, port: int) -> List[Dict]:
        """Check SSL/TLS cipher strength using testssl.sh or OpenSSL"""
        vulnerabilities = []
        
        try:
            # Try using testssl.sh first for comprehensive cipher analysis
            testssl_ciphers = self.check_ciphers_with_testssl(hostname, port)
            vulnerabilities.extend(testssl_ciphers)
            
        except Exception as e:
            print(f"Cipher strength check failed: {e}")
            # Fallback to basic OpenSSL check
            basic_ciphers = self.check_ciphers_basic(hostname, port)
            vulnerabilities.extend(basic_ciphers)
        
        return vulnerabilities

    def check_ciphers_with_testssl(self, hostname: str, port: int) -> List[Dict]:
        """Check ciphers using testssl.sh"""
        vulnerabilities = []
        
        try:
            # Run testssl.sh cipher check
            cmd = f"testssl.sh --jsonfile {self.temp_dir}/ciphers.json -E {hostname}:{port}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=180)
            
            if result.returncode == 0 and os.path.exists(f"{self.temp_dir}/ciphers.json"):
                with open(f"{self.temp_dir}/ciphers.json", 'r') as f:
                    cipher_data = json.load(f)
                    vulnerabilities.extend(self.parse_cipher_findings(cipher_data))
                    
        except Exception as e:
            print(f"testssl.sh cipher check failed: {e}")
        
        return vulnerabilities

    def check_ciphers_basic(self, hostname: str, port: int) -> List[Dict]:
        """Basic cipher check using OpenSSL"""
        vulnerabilities = []
        
        # Weak ciphers to check for
        weak_ciphers = [
            'NULL', 'EXPORT', 'RC4', 'DES', '3DES', 'MD5', 
            'CBC', 'TLS_RSA_WITH', 'TLS_DHE_RSA_WITH'
        ]
        
        # Medium strength ciphers
        medium_ciphers = [
            'TLS_RSA_WITH_AES_128', 'TLS_RSA_WITH_AES_256'
        ]
        
        try:
            # Test connection with different cipher suites
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cipher = ssock.cipher()
                    if cipher:
                        cipher_name = cipher[0]
                        
                        # Check for weak ciphers
                        if any(weak in cipher_name for weak in weak_ciphers):
                            vulnerabilities.append({
                                'type': 'WEAK_CIPHER_SUITE',
                                'severity': 'HIGH',
                                'description': f'Weak cipher suite enabled: {cipher_name}',
                                'recommendation': 'Disable weak cipher suites and use strong, modern ciphers',
                                'evidence': f'Active cipher: {cipher_name}',
                                'source': 'openssl_cipher_check'
                            })
                        elif any(medium in cipher_name for medium in medium_ciphers):
                            vulnerabilities.append({
                                'type': 'MEDIUM_STRENGTH_CIPHER',
                                'severity': 'MEDIUM',
                                'description': f'Medium strength cipher suite: {cipher_name}',
                                'recommendation': 'Consider using stronger cipher suites',
                                'evidence': f'Active cipher: {cipher_name}',
                                'source': 'openssl_cipher_check'
                            })
                            
        except Exception as e:
            print(f"Basic cipher check failed: {e}")
        
        return vulnerabilities

    def parse_cipher_findings(self, cipher_data: Dict) -> List[Dict]:
        """Parse cipher findings from testssl.sh output"""
        vulnerabilities = []
        
        try:
            for scan in cipher_data.get('scanResult', []):
                id = scan.get('id', '')
                finding = scan.get('finding', '')
                severity = scan.get('severity', 'INFO')
                
                if 'cipher' in id.lower() and severity in ['MEDIUM', 'HIGH', 'CRITICAL']:
                    vuln_severity = self.map_testssl_severity(severity)
                    
                    vulnerabilities.append({
                        'type': f'WEAK_CIPHER_{id.upper()}',
                        'severity': vuln_severity,
                        'description': f'Weak cipher finding: {finding}',
                        'recommendation': 'Disable weak cipher suites and use AES-GCM, ChaCha20 with forward secrecy',
                        'evidence': finding,
                        'source': 'testssl.sh'
                    })
                    
        except Exception as e:
            print(f"Cipher findings parsing failed: {e}")
        
        return vulnerabilities

    def analyze_cookie_security(self, target: str) -> List[Dict]:
        """Comprehensive cookie security analysis"""
        vulnerabilities = []
        
        try:
            # Make initial request to get cookies
            response = requests.get(target, timeout=10, verify=False, allow_redirects=True)
            cookies = response.cookies
            
            # Check each cookie for security attributes
            for cookie in cookies:
                cookie_issues = self.analyze_single_cookie(cookie, target)
                vulnerabilities.extend(cookie_issues)
            
            # Check Set-Cookie headers for additional cookies
            set_cookie_headers = response.headers.get('Set-Cookie', '')
            if set_cookie_headers:
                header_issues = self.analyze_set_cookie_headers(set_cookie_headers, target)
                vulnerabilities.extend(header_issues)
                
        except Exception as e:
            print(f"Cookie security analysis failed: {e}")
            vulnerabilities.append({
                'type': 'COOKIE_ANALYSIS_ERROR',
                'severity': 'LOW',
                'description': f'Cookie analysis failed: {str(e)}',
                'recommendation': 'Manual review of cookie security recommended',
                'source': 'cookie_analysis'
            })
        
        return vulnerabilities

    def analyze_single_cookie(self, cookie, target: str) -> List[Dict]:
        """Analyze security attributes of a single cookie"""
        issues = []
        
        cookie_name = cookie.name
        domain = cookie.domain or target
        
        # Check for Secure flag
        if not cookie.secure:
            issues.append({
                'type': 'COOKIE_MISSING_SECURE_FLAG',
                'severity': 'MEDIUM',
                'description': f'Cookie "{cookie_name}" missing Secure flag',
                'recommendation': 'Set Secure flag on all cookies to prevent transmission over HTTP',
                'evidence': f'Cookie: {cookie_name}, Domain: {domain}',
                'source': 'cookie_analysis'
            })
        
        # Check for HttpOnly flag
        if not cookie.has_nonstandard_attr('HttpOnly'):
            # Try to check via attribute access
            if not getattr(cookie, '_rest', {}).get('HttpOnly', False):
                issues.append({
                    'type': 'COOKIE_MISSING_HTTPONLY_FLAG',
                    'severity': 'MEDIUM',
                    'description': f'Cookie "{cookie_name}" missing HttpOnly flag',
                    'recommendation': 'Set HttpOnly flag to prevent client-side script access',
                    'evidence': f'Cookie: {cookie_name}, Domain: {domain}',
                    'source': 'cookie_analysis'
                })
        
        # Check for SameSite attribute
        samesite = getattr(cookie, '_rest', {}).get('SameSite', None)
        if not samesite or samesite.upper() not in ['STRICT', 'LAX']:
            issues.append({
                'type': 'COOKIE_MISSING_SAMESITE_ATTRIBUTE',
                'severity': 'LOW',
                'description': f'Cookie "{cookie_name}" missing or weak SameSite attribute',
                'recommendation': 'Set SameSite=Strict or SameSite=Lax to prevent CSRF attacks',
                'evidence': f'Cookie: {cookie_name}, SameSite: {samesite or "Not set"}',
                'source': 'cookie_analysis'
            })
        
        # Check for overly broad domain scope
        if cookie.domain and cookie.domain.startswith('.'):
            if len(cookie.domain) < 4:  # Very broad domain like ".com"
                issues.append({
                    'type': 'COOKIE_OVERLY_BROAD_DOMAIN',
                    'severity': 'MEDIUM',
                    'description': f'Cookie "{cookie_name}" has overly broad domain scope',
                    'recommendation': 'Restrict cookie domain to specific subdomains',
                    'evidence': f'Cookie: {cookie_name}, Domain: {cookie.domain}',
                    'source': 'cookie_analysis'
                })
        
        # Check for session fixation issues
        if cookie_name.lower() in ['sessionid', 'jsessionid', 'phpsessid', 'asp.net_sessionid']:
            if not cookie.secure or not getattr(cookie, '_rest', {}).get('HttpOnly', False):
                issues.append({
                    'type': 'SESSION_COOKIE_INSECURE',
                    'severity': 'HIGH',
                    'description': f'Session cookie "{cookie_name}" has insecure attributes',
                    'recommendation': 'Session cookies must have Secure and HttpOnly flags',
                    'evidence': f'Session cookie: {cookie_name}',
                    'source': 'cookie_analysis'
                })
        
        return issues

    def analyze_set_cookie_headers(self, set_cookie_headers: str, target: str) -> List[Dict]:
        """Analyze Set-Cookie headers for security attributes"""
        issues = []
        
        try:
            # Parse multiple Set-Cookie headers
            if isinstance(set_cookie_headers, str):
                cookie_strings = [set_cookie_headers]
            else:
                cookie_strings = set_cookie_headers
                
            for cookie_str in cookie_strings:
                # Basic parsing of Set-Cookie header
                parts = cookie_str.split(';')
                if parts:
                    cookie_name_value = parts[0].strip()
                    if '=' in cookie_name_value:
                        cookie_name = cookie_name_value.split('=')[0]
                        
                        # Check for security attributes in the header
                        attributes = ';'.join(parts[1:]).lower()
                        
                        if 'secure' not in attributes:
                            issues.append({
                                'type': 'COOKIE_MISSING_SECURE_FLAG',
                                'severity': 'MEDIUM',
                                'description': f'Cookie "{cookie_name}" missing Secure flag in Set-Cookie',
                                'recommendation': 'Add Secure flag to Set-Cookie header',
                                'evidence': f'Set-Cookie: {cookie_str}',
                                'source': 'cookie_analysis'
                            })
                        
                        if 'httponly' not in attributes:
                            issues.append({
                                'type': 'COOKIE_MISSING_HTTPONLY_FLAG',
                                'severity': 'MEDIUM',
                                'description': f'Cookie "{cookie_name}" missing HttpOnly flag in Set-Cookie',
                                'recommendation': 'Add HttpOnly flag to Set-Cookie header',
                                'evidence': f'Set-Cookie: {cookie_str}',
                                'source': 'cookie_analysis'
                            })
                        
                        if 'samesite' not in attributes:
                            issues.append({
                                'type': 'COOKIE_MISSING_SAMESITE_ATTRIBUTE',
                                'severity': 'LOW',
                                'description': f'Cookie "{cookie_name}" missing SameSite attribute in Set-Cookie',
                                'recommendation': 'Add SameSite=Strict or SameSite=Lax to Set-Cookie header',
                                'evidence': f'Set-Cookie: {cookie_str}',
                                'source': 'cookie_analysis'
                            })
                            
        except Exception as e:
            print(f"Set-Cookie header analysis failed: {e}")
        
        return issues

    def analyze_web_ssl(self, target: str) -> List[Dict]:
        """Analyze web SSL configuration specifically for web services"""
        vulnerabilities = []
        
        try:
            # Extract hostname and port from target
            if '://' in target:
                protocol, rest = target.split('://', 1)
                hostname = rest.split('/')[0].split(':')[0]
                port = 443 if protocol == 'https' else 80
            else:
                hostname = target.split('/')[0].split(':')[0]
                port = 80
            
            # If port is 80 but target uses HTTPS, adjust port
            if port == 80 and target.startswith('https://'):
                port = 443
            
            # Perform SSL analysis on the determined port
            if port in [443, 8443, 9443]:  # Common SSL ports
                # Get certificate information
                cert_info = self.get_certificate_info(hostname, port)
                
                if cert_info and 'error' not in cert_info:
                    cert_vulns = self.check_certificate_vulnerabilities(cert_info)
                    vulnerabilities.extend(cert_vulns)
                    
                    # Check protocol support
                    proto_info = self.check_protocol_support(hostname, port)
                    vulnerabilities.extend(proto_info.get('vulnerabilities', []))
                    
                    # Check cipher strength
                    cipher_vulns = self.check_cipher_strength(hostname, port)
                    vulnerabilities.extend(cipher_vulns)
                else:
                    vulnerabilities.append({
                        'type': 'SSL_CERTIFICATE_ERROR',
                        'severity': 'HIGH',
                        'description': f'Cannot retrieve SSL certificate for {hostname}:{port}',
                        'recommendation': 'Check SSL certificate configuration and accessibility',
                        'evidence': f'Certificate error: {cert_info.get("error", "Unknown")}',
                        'source': 'web_ssl_analysis'
                    })
            else:
                vulnerabilities.append({
                    'type': 'NO_SSL_ENDPOINT',
                    'severity': 'INFO',
                    'description': f'Target {target} does not appear to use SSL/TLS',
                    'recommendation': 'Consider implementing SSL/TLS for secure communications',
                    'evidence': f'Target uses port {port} which is typically not SSL-enabled',
                    'source': 'web_ssl_analysis'
                })
                
        except Exception as e:
            print(f"Web SSL analysis failed: {e}")
            vulnerabilities.append({
                'type': 'WEB_SSL_ANALYSIS_ERROR',
                'severity': 'MEDIUM',
                'description': f'Web SSL analysis failed: {str(e)}',
                'recommendation': 'Manual SSL/TLS configuration review recommended',
                'source': 'web_ssl_analysis'
            })
        
        return vulnerabilities

    def scan_ssh_vulnerabilities(self, target: str, port: int, version: str) -> List[Dict]:
        """Scan SSH service for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for weak SSH configurations using nmap
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script ssh2-enum-algos,ssh-auth-methods')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        # Check SSH algorithms
                        if 'ssh2-enum-algos' in scripts:
                            algos_output = scripts['ssh2-enum-algos']
                            if 'weak' in algos_output.lower():
                                vulnerabilities.append({
                                    'type': 'SSH_WEAK_ALGORITHMS',
                                    'severity': 'MEDIUM',
                                    'description': 'SSH service uses weak encryption algorithms',
                                    'recommendation': 'Disable weak algorithms and use strong ones like aes256-ctr',
                                    'evidence': algos_output,
                                    'source': 'ssh_scan'
                                })
                        
                        # Check authentication methods
                        if 'ssh-auth-methods' in scripts:
                            auth_output = scripts['ssh-auth-methods']
                            if 'password' in auth_output and 'publickey' not in auth_output:
                                vulnerabilities.append({
                                    'type': 'SSH_PASSWORD_ONLY_AUTH',
                                    'severity': 'MEDIUM',
                                    'description': 'SSH allows password authentication without public key',
                                    'recommendation': 'Enable public key authentication and consider disabling password auth',
                                    'evidence': auth_output,
                                    'source': 'ssh_scan'
                                })
            
            # Version-specific vulnerabilities
            if version:
                if '7.4' in version or '7.5' in version:  # Example version checks
                    vulnerabilities.append({
                        'type': 'SSH_VERSION_VULNERABILITY',
                        'severity': 'LOW',
                        'description': f'SSH version {version} may have known vulnerabilities',
                        'recommendation': 'Update SSH to latest version',
                        'evidence': f'SSH version detected: {version}',
                        'source': 'ssh_version_check'
                    })
                    
        except Exception as e:
            print(f"SSH vulnerability scan failed: {e}")
        
        return vulnerabilities

    def scan_ftp_vulnerabilities(self, target: str, port: int, version: str) -> List[Dict]:
        """Scan FTP service for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for anonymous FTP access
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script ftp-anon')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        if 'ftp-anon' in scripts:
                            anon_output = scripts['ftp-anon']
                            if 'Anonymous FTP login allowed' in anon_output:
                                vulnerabilities.append({
                                    'type': 'FTP_ANONYMOUS_ACCESS',
                                    'severity': 'HIGH',
                                    'description': 'FTP allows anonymous access',
                                    'recommendation': 'Disable anonymous FTP access',
                                    'evidence': anon_output,
                                    'source': 'ftp_scan'
                                })
            
            # FTP typically uses cleartext credentials
            vulnerabilities.append({
                'type': 'FTP_CLEARTEXT_PROTOCOL',
                'severity': 'HIGH',
                'description': 'FTP transmits credentials in cleartext',
                'recommendation': 'Use SFTP or FTPS instead of FTP',
                'evidence': 'FTP protocol analysis',
                'source': 'ftp_analysis'
            })
            
        except Exception as e:
            print(f"FTP vulnerability scan failed: {e}")
        
        return vulnerabilities

    def scan_telnet_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Scan Telnet service for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Telnet is inherently insecure
            vulnerabilities.append({
                'type': 'TELNET_INSECURE_PROTOCOL',
                'severity': 'HIGH',
                'description': 'Telnet service detected - transmits all data in cleartext',
                'recommendation': 'Replace Telnet with SSH',
                'evidence': f'Telnet service running on {target}:{port}',
                'source': 'telnet_analysis'
            })
            
            # Check for specific Telnet vulnerabilities
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script telnet-encryption')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        if 'telnet-encryption' in scripts:
                            enc_output = scripts['telnet-encryption']
                            if 'No encryption' in enc_output:
                                vulnerabilities.append({
                                    'type': 'TELNET_NO_ENCRYPTION',
                                    'severity': 'HIGH',
                                    'description': 'Telnet connection uses no encryption',
                                    'recommendation': 'Immediately disable Telnet and use SSH',
                                    'evidence': enc_output,
                                    'source': 'telnet_scan'
                                })
                                
        except Exception as e:
            print(f"Telnet vulnerability scan failed: {e}")
        
        return vulnerabilities

    def scan_smb_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Scan SMB service for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for SMB vulnerabilities
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script smb-vuln-*,smb2-security-mode')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        # Check for specific SMB vulnerabilities
                        for script_name, script_output in scripts.items():
                            if 'vuln' in script_name.lower():
                                vulnerabilities.append({
                                    'type': f'SMB_{script_name.upper()}',
                                    'severity': 'HIGH',
                                    'description': f'SMB vulnerability detected: {script_name}',
                                    'recommendation': 'Apply SMB security patches and disable SMBv1 if possible',
                                    'evidence': script_output,
                                    'source': 'smb_scan'
                                })
                        
                        # Check SMB security mode
                        if 'smb2-security-mode' in scripts:
                            mode_output = scripts['smb2-security-mode']
                            if 'Message signing enabled but not required' in mode_output:
                                vulnerabilities.append({
                                    'type': 'SMB_SIGNING_NOT_REQUIRED',
                                    'severity': 'MEDIUM',
                                    'description': 'SMB signing enabled but not required',
                                    'recommendation': 'Require SMB message signing',
                                    'evidence': mode_output,
                                    'source': 'smb_scan'
                                })
                                
        except Exception as e:
            print(f"SMB vulnerability scan failed: {e}")
        
        return vulnerabilities

    def scan_rdp_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Scan RDP service for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for RDP vulnerabilities
            scan_result = self.nm.scan(target, arguments=f'-p {port} --script rdp-*')
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    if port in self.nm[host][proto]:
                        port_info = self.nm[host][proto][port]
                        scripts = port_info.get('script', {})
                        
                        # Check for specific RDP issues
                        for script_name, script_output in scripts.items():
                            if 'rdp' in script_name.lower():
                                if 'vuln' in script_name.lower() or 'CVE' in script_output:
                                    vulnerabilities.append({
                                        'type': f'RDP_{script_name.upper()}',
                                        'severity': 'HIGH',
                                        'description': f'RDP vulnerability detected: {script_name}',
                                        'recommendation': 'Apply RDP security patches and restrict access',
                                        'evidence': script_output,
                                        'source': 'rdp_scan'
                                    })
            
            # General RDP security recommendations
            vulnerabilities.append({
                'type': 'RDP_EXPOSED_SERVICE',
                'severity': 'MEDIUM',
                'description': 'RDP service exposed to network',
                'recommendation': 'Restrict RDP access with firewall rules and use Network Level Authentication',
                'evidence': f'RDP service running on {target}:{port}',
                'source': 'rdp_analysis'
            })
            
        except Exception as e:
            print(f"RDP vulnerability scan failed: {e}")
        
        return vulnerabilities

    def check_general_service_vulnerabilities(self, service: Dict, target: str) -> List[Dict]:
        """Check for general service vulnerabilities"""
        vulnerabilities = []
        
        service_name = service['name']
        version = service.get('version', '')
        port = service['port']
        
        # Check for default or well-known ports
        well_known_ports = {
            'ssh': 22, 'ftp': 21, 'telnet': 23, 'smtp': 25,
            'http': 80, 'https': 443, 'rdp': 3389
        }
        
        if service_name in well_known_ports and port == well_known_ports[service_name]:
            vulnerabilities.append({
                'type': 'SERVICE_ON_DEFAULT_PORT',
                'severity': 'LOW',
                'description': f'{service_name} running on default port {port}',
                'recommendation': f'Consider changing {service_name} to a non-default port',
                'evidence': f'{service_name} on port {port}',
                'source': 'service_analysis'
            })
        
        # Check for outdated service banners
        if version and any(old in version.lower() for old in ['test', 'debug', 'development']):
            vulnerabilities.append({
                'type': 'SERVICE_DEBUG_BUILD',
                'severity': 'MEDIUM',
                'description': f'{service_name} appears to be a debug/development build',
                'recommendation': 'Use production builds in production environments',
                'evidence': f'Version: {version}',
                'source': 'service_analysis'
            })
        
        return vulnerabilities

    def check_version_vulnerabilities(self, service_name: str, version: str) -> List[Dict]:
        """Check for version-specific vulnerabilities"""
        vulnerabilities = []
        
        # This would typically integrate with a CVE database
        # For now, we'll check some common patterns
        
        known_vulnerable_versions = {
            'apache': ['2.4.49', '2.4.50'],  # Path traversal vulnerabilities
            'openssh': ['7.4', '7.5'],       # Example vulnerable versions
            'nginx': ['1.18.0', '1.19.0'],   # Example
        }
        
        service_lower = service_name.lower()
        for service, vulnerable_versions in known_vulnerable_versions.items():
            if service in service_lower:
                for vuln_version in vulnerable_versions:
                    if vuln_version in version:
                        vulnerabilities.append({
                            'type': 'KNOWN_VULNERABLE_VERSION',
                            'severity': 'HIGH',
                            'description': f'{service_name} version {version} has known vulnerabilities',
                            'recommendation': f'Update {service_name} to latest secure version',
                            'evidence': f'Vulnerable version detected: {version}',
                            'source': 'version_analysis'
                        })
                        break
        
        return vulnerabilities

