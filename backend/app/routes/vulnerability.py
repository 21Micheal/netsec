from flask import Blueprint, request, jsonify
from app.models import ScanJob, ScanType, JobStatus, Vulnerability, Asset, db
import uuid
from datetime import datetime

vulnerability_bp = Blueprint('vulnerability', __name__)

@vulnerability_bp.route('/api/vulnerability/scan', methods=['POST'])
def start_vulnerability_scan():
    """Start a vulnerability assessment scan"""
    data = request.get_json()
    
    required_fields = ['target', 'assessment_type']
    if not all(field in data for field in required_fields):
        return jsonify({'error': 'Missing required fields: target, assessment_type'}), 400
    
    try:
        # Create scan job
        scan_job = ScanJob(
            id=uuid.uuid4(),
            target=data['target'],
            scan_type=ScanType.vulnerability_assessment,
            profile=data.get('profile', 'default'),
            status=JobStatus.queued,
            config={
                'assessment_type': data['assessment_type'],
                'aggressive': data.get('aggressive', False),
                'web_scan_config': data.get('web_scan_config', {}),
                'ssl_config': data.get('ssl_config', {}),
                'cve_config': data.get('cve_config', {}),
                'credential_config': data.get('credential_config', {})
            }
        )
        
        db.session.add(scan_job)
        db.session.commit()
        
        # Start appropriate Celery task based on assessment type
        from app.workers.tasks import (
            run_web_vulnerability_scan,
            run_ssl_analysis,
            run_cve_scan,
            run_credential_testing,
            run_vulnerability_scan
        )
        assessment_type = data['assessment_type']
        if assessment_type == 'web_security':
            task = run_web_vulnerability_scan.delay(str(scan_job.id))
        elif assessment_type == 'ssl_analysis':
            task = run_ssl_analysis.delay(str(scan_job.id))
        elif assessment_type == 'cve_scan':
            task = run_cve_scan.delay(str(scan_job.id))
        elif assessment_type == 'credential_testing':
            task = run_credential_testing.delay(str(scan_job.id))
        else:  # full assessment
            task = run_vulnerability_scan.delay(str(scan_job.id))
        
        return jsonify({
            'job_id': str(scan_job.id),
            'status': 'queued',
            'message': f'Vulnerability assessment started for {data["target"]}'
        }), 202
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'Failed to start scan: {str(e)}'}), 500

@vulnerability_bp.route('/api/vulnerability/scan/<job_id>', methods=['GET'])
def get_scan_status(job_id):
    """Get vulnerability scan status and results"""
    try:
        scan_job = ScanJob.query.get(uuid.UUID(job_id))
        if not scan_job:
            return jsonify({'error': 'Scan job not found'}), 404
        
        return jsonify(scan_job.to_dict()), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@vulnerability_bp.route('/api/vulnerability/scans', methods=['GET'])
def get_vulnerability_scans():
    """Get all vulnerability assessment scans"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        
        scans = ScanJob.query.filter_by(scan_type=ScanType.vulnerability_assessment)\
                            .order_by(ScanJob.created_at.desc())\
                            .paginate(page=page, per_page=per_page, error_out=False)
        
        return jsonify({
            'scans': [scan.to_dict() for scan in scans.items],
            'total': scans.total,
            'pages': scans.pages,
            'current_page': page
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@vulnerability_bp.route('/api/vulnerability/findings', methods=['GET'])
def get_vulnerability_findings():
    """Get vulnerability findings with filtering"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        severity = request.args.get('severity')
        status = request.args.get('status')
        
        query = Vulnerability.query
        
        if severity:
            query = query.filter_by(severity=severity.upper())
        if status:
            query = query.filter_by(status=status)
            
        vulnerabilities = query.order_by(Vulnerability.discovered_at.desc())\
                              .paginate(page=page, per_page=per_page, error_out=False)
        
        return jsonify({
            'vulnerabilities': [vuln.to_dict() for vuln in vulnerabilities.items],
            'total': vulnerabilities.total,
            'pages': vulnerabilities.pages,
            'current_page': page
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@vulnerability_bp.route('/api/vulnerability/stats', methods=['GET'])
def get_vulnerability_stats():
    """Get vulnerability statistics"""
    try:
        # Total vulnerabilities by severity
        severity_stats = db.session.query(
            Vulnerability.severity,
            db.func.count(Vulnerability.id)
        ).group_by(Vulnerability.severity).all()
        
        # Vulnerabilities by status
        status_stats = db.session.query(
            Vulnerability.status,
            db.func.count(Vulnerability.id)
        ).group_by(Vulnerability.status).all()
        
        # Recent high severity vulnerabilities
        recent_critical = Vulnerability.query.filter(
            Vulnerability.severity.in_(['CRITICAL', 'HIGH']),
            Vulnerability.status == 'open'
        ).order_by(Vulnerability.discovered_at.desc()).limit(5).all()
        
        return jsonify({
            'severity_distribution': dict(severity_stats),
            'status_distribution': {status.value: count for status, count in status_stats},
            'recent_critical': [vuln.to_dict() for vuln in recent_critical],
            'total_vulnerabilities': sum(count for _, count in severity_stats)
        }), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@vulnerability_bp.route('/api/vulnerability/finding/<vuln_id>', methods=['PUT'])
def update_vulnerability_status(vuln_id):
    """Update vulnerability status"""
    try:
        data = request.get_json()
        vuln = Vulnerability.query.get(uuid.UUID(vuln_id))
        
        if not vuln:
            return jsonify({'error': 'Vulnerability not found'}), 404
            
        if 'status' in data:
            vuln.status = data['status']
            if data['status'] == 'fixed':
                vuln.fixed_at = datetime.utcnow()
                
        db.session.commit()
        
        return jsonify(vuln.to_dict()), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500
    
# Test route to check if blueprint is working
@vulnerability_bp.route('/api/vulnerability/test', methods=['GET'])
def test_vulnerability():
    return jsonify({'message': 'Vulnerability routes are working!'}), 200